# Quick Reference

## Table of Contents:

- **[Tubes](#tubes)**
  - [Available Tubes](#available-tubes)
  - [Receiving data from tube](#receiving-data-from-tube)
  - [Sending data through tube](#sending-data-through-tube)
- **[Utilities (packing,unpacking, encoding, pattern generation,etc)](#utilities)**
  - [Packing](#packing)
  - [Unpacking](#unpacking)
  - [File I/O](#file-io)
  - [Hashing and Encoding](#hashing-and-encoding)
- **[ELF](#elf)**
  - [Symbols](#symbols)
  - [Changing base address](#changing-base-address)
  - [Reading from elf](#reading-from-elf)
  - [Disassembling elf](#disassembling-elf)
  - [Patching elf](#patching-elf)
  - [Searching in elf](#searching-in-elf)

- **[Assembly](#assembly)**
  - [In python script](#in-python-script)
  - [In command-line](#in-command-line)

- **[ROP](#rop)**
  - [Finding gadgets](#finding-gadgets)
  - [Calling functions 'magically'](#calling-functions-magically)

- **[Logging](#logging)**

## Tubes

### Available tubes:
  - **Local process (any binary)**
  ```
  # Without arguments passed to the binary
  io = process('vuln_binary')

  # With arguments
  io = process(['vuln_binary','--some-param','value'])
  ```
  - **Remote server**
  ```
  io = remote('server-ip', port)
  ```
  - **SSH**
  ```
  # First, connect and authenticate to ssh server
  session = ssh('username', 'ssh-server-ip', password='password')

  # Then work with some binary on that server
  io = session.process('vuln_binary', env={"PS1":""})
  ```
  - **Listen for inbound connections**
  ```
  io = listen(port_num).wait_for_connection()
  ```
**The 'io' object in all of the tubes can then be used to interact directly with the process. All method names will remain same no matter whichever tube is used.**

### Receiving data from tube
- `recv(n)` - Receive any number of available bytes
- `recvline()` - Receive data until a newline is encountered
- `recvuntil(delim)` - Receive data until a delimiter is found
- `recvregex(pattern)` - Receive data until a regex pattern is satisfied
- `recvrepeat(timeout)` - Keep receiving data until a timeout occurs
- `clean()` - Discard all buffered data

### Sending data through tube
- `send(data)` - Sends data
- `sendline(line)` - Sends data plus a newline

## Utilities
### Packing
  - `p16(addr)` # Packs 16-bit int address
  - `p32(addr)` # Packs 32-bit int address
  - `p64(addr)` # Packs 64-bit int address
  - `pack(addr)` # requires context, packs int address accordingly
  Additional param is 'endian'.
### Unpacking
  - `u16(str)` # Unpacks 16-bit address
  - `u32(str)` # Unpacks 32-bit address
  - `u64(str)` # Unpacks 64-bit address
  - `unpack(str)` # requires context, unpacks accordingly
### File I/O
  - `write(file_to_write_to,str_to_write)`
  - `read(file_to_read_from)`

### Hashing and Encoding
- Base64
  - `b64e(string_to_encode)`
  - `b64d(string_to_decode)`
- Hashing
  - `md5sumhex(str)`
  - `md5filehex(filename)`
  - `sha1sumhex(str)`
- URL Encoding
  `urlencode(str)`
- Hex Encoding
  - enhex(string_to_encode)
  - unhex(string_to_decode)
- Pattern Generation
  - Create De-Brujin pattern
    `cyclic(int)`
  - Find offset in pattern
    `cyclic_find(hex,int,etc)`

## ELF
`elf = ELF(vuln_binary)`
  ### Symbols
  All of these will return a dictionary.
  - `ELF.symbols` - Lists all known symbols, including those below. Preference is given the PLT entries over GOT entries.
  - `ELF.got` - Only contains GOT entries
  - `ELF.plt` - Only contains PLT entries
  - `ELF.functions` - Only contains functions (requires DWARF symbols)
  ### Changing base address
  `elf.address=<addr>`
  ### Reading from elf
  `elf.read(addr,no_of_bytes)` - Reads no_of_bytes from specified addr of elf.
  ### Disassembling elf
  `elf.disasm(addr_to_disasm_at, no_of_bytes_to_disasm)`
  ### Patching elf
  - Replacing assembly code:
  `elf.asm(addr_to_patch, assembly_code_str)`
  - Replacing symbol addresses:
  `elf.pack(addr_to_replace, addr_to_replace_with)`
  *This can be a pointer to some address. Example: 'addr_to_replace' can be the got entry of a function, 'addr_to_replace_with' can be the plt table of a function you want to redirect to everytime the actual function is called*
  - Replace value at an address
    ```
    addr_to_patch_val_at = <something>
    val = elf.unpack(addr_to_patch_val_at)
    elf.write(val, new_value)
    ```
    *String values must end with a null byte*
  - Saving the modified binary
  `elf.save(new_filename)`
  ### Searching in elf
  `elf.search(what_to_search)`
  *This returns an iterator*

## Assembly
### In python script:
- **Converting assembly to shellcode -** 
`asm(str_of_asm_instruction)`
*Multiple instructions are just comma-separated, like: asm('push rdi, push rsi, ret')*
*Also, you might wanna see the shellcode encoded in hex, in which case, use enhex() function over asm(), like enhex(asm(str_of_asm_instruction))*

### In command-line:
- **Converting assembly to shellcode -**
  `asm "str_of_instruction"`
  *Separate multiple instructions with a semi-colon(;)*
- **Converting shellcode to assembly**
  `disasm <shellcode>`

## ROP
`rop = ROP(elf) # elf is an ELF object`
### Finding gadgets:
`rop.reg1_reg2_reg3`
  *Will return a list of Gadget objects, that are actually rop gadgets that pops reg1, reg2, etc in that sequence, and returns*
### Calling functions 'magically'
> The real power of Pwntools' ROP tooling is the ability to invoke arbitrary functions, either via magic accessors or via the ROP.call() routine.
- **Calling by address:**
`rop.call(addr_of_func, [arg1, arg2...])`
- **Calling by function name:**
`rop.execve(addr_of_symbol)`
## Logging
- `info(str)` -> [*] str
- `warn(str)` -> [!] str
- `error(str)`
- `debug(str)` 

