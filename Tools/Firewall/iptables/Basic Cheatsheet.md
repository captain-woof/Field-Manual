# iptables

## Table of Contents

- **[How it works](#how-it-works)**
- **[Default tables](#default-tables)**
- **[Commands](#commands)**
  - [What the commands do](#what-the-commands-do)
  - [Base commands](#base-commands)
  - [Parameters](#parameters)
- **[Quick examples](#quick-examples)**

## How it works
**iptables uses some ACL tables** that contain rules that are used to judge when and what to do when a packet comes in, goes out or moves around the network.

**Each table has sections called 'chains'**, that are like sub-divisions that are used according to the situation.

**Each rule in a chain contain characteristics of a packet, and an action that should be taken.**

When a new packet is in transit, **the rules in the tables are consulted to see which of the rules (i.e, the characteristics mentioned in the rule) match with the packet.** This can be compared with if-elses in programming when a condition is checked, and actions are taken accordingly. If a rule gets matched, the action mentioned in the rule is taken, and no other rules below that in the ACL is consulted.

## Default tables

iptables contains some rule tables that are consulted when packets come or leave the host. There are 4 such tables:

  - **filter:** 
    This is the **default table** (if no -t option is passed). It contains the built-in chains:
     - **INPUT** (for packets destined to local sockets)
     - **FORWARD** (for packets being routed through the box)
     - **OUTPUT** (for locally-generated packets). 
  - **nat:**
    This table is consulted when a packet that creates a new connection is encountered. It consists of three built-ins:
      - **PREROUTING** (for altering packets as soon as they come in)
      - **OUTPUT** (for altering locally-generated packets before routing)
      - **POSTROUTING** (for altering packets as they are about to go out). 
  - **mangle:** 
    This table is used for specialized packet alteration.
    
    Until kernel 2.4.17 it had two built-in chains:
      - **PREROUTING** (for altering incoming packets before routing)
      - **OUTPUT** (for altering locally-generated packets before routing).
      
    Since kernel 2.4.18, three other built-in chains are also supported:
      - **INPUT** (for packets coming into the box itself)
      - **FORWARD** (for altering packets being routed through the box)
      - **POSTROUTING** (for altering packets as they are about to go out). 
  - **raw:** 
    This table is used mainly for configuring exemptions from connection tracking in combination with the NOTRACK target. It registers at the netfilter hooks with higher priority and is thus called before ip_conntrack, or any other IP tables. It provides the following built-in chains:
      - **PREROUTING** (for packets arriving via any network interface)
      - **OUTPUT** (for packets generated by local processes) 

## Commands

### What the commands do
The commands you will use with iptables consists of 2 parts:

  1. The **base command** - it defines the primary type of 'thing' to do.
  2. The **parameters** - it defines the condition (rule) that must be matched, and what to do if it matches.

### Base commands
```
-A, --append chain rule-specification
    Append one or more rules to the end of the selected chain. When the source and/or destination names resolve to more than one address, a rule will be added for each possible address combination. 
-D, --delete chain rule-specification
-D, --delete chain rulenum
    Delete one or more rules from the selected chain. There are two versions of this command: the rule can be specified as a number in the chain (starting at 1 for the first rule) or a rule to match. 
-I, --insert chain [rulenum] rule-specification
    Insert one or more rules in the selected chain as the given rule number. So, if the rule number is 1, the rule or rules are inserted at the head of the chain. This is also the default if no rule number is specified. 
-R, --replace chain rulenum rule-specification
    Replace a rule in the selected chain. If the source and/or destination names resolve to multiple addresses, the command will fail. Rules are numbered starting at 1. 
-L, --list [chain]
    List all rules in the selected chain. If no chain is selected, all chains are listed. As every other iptables command, it applies to the specified table (filter is the default), so NAT rules get listed by

    iptables -t nat -n -L

    Please note that it is often used with the -n option, in order to avoid long reverse DNS lookups. It is legal to specify the -Z (zero) option as well, in which case the chain(s) will be atomically listed and zeroed. The exact output is affected by the other arguments given. The exact rules are suppressed until you use

    iptables -L -v

-F, --flush [chain]
    Flush the selected chain (all the chains in the table if none is given). This is equivalent to deleting all the rules one by one. 
-Z, --zero [chain]
    Zero the packet and byte counters in all chains. It is legal to specify the -L, --list (list) option as well, to see the counters immediately before they are cleared. (See above.) 
-N, --new-chain chain
    Create a new user-defined chain by the given name. There must be no target of that name already. 
-X, --delete-chain [chain]
    Delete the optional user-defined chain specified. There must be no references to the chain. If there are, you must delete or replace the referring rules before the chain can be deleted. The chain must be empty, i.e. not contain any rules. If no argument is given, it will attempt to delete every non-builtin chain in the table. 
-P, --policy chain target
    Set the policy for the chain to the given target. See the section TARGETS for the legal targets. Only built-in (non-user-defined) chains can have policies, and neither built-in nor user-defined chains can be policy targets. 
-E, --rename-chain old-chain new-chain
    Rename the user specified chain to the user supplied name. This is cosmetic, and has no effect on the structure of the table. 
-h

Help. Give a (currently very brief) description of the command syntax. 
```

### Parameters
```
-p, --protocol [!] protocol
    The protocol of the rule or of the packet to check. The specified protocol can be one of tcp, udp, icmp, or all, or it can be a numeric value, representing one of these protocols or a different one. A protocol name from /etc/protocols is also allowed. A "!" argument before the protocol inverts the test. The number zero is equivalent to all. Protocol all will match with all protocols and is taken as default when this option is omitted. 
-s, --source [!] address[/mask]
    Source specification. Address can be either a network name, a hostname (please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea), a network IP address (with /mask), or a plain IP address. The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A "!" argument before the address specification inverts the sense of the address. The flag --src is an alias for this option. 
-d, --destination [!] address[/mask]
    Destination specification. See the description of the -s (source) flag for a detailed description of the syntax. The flag --dst is an alias for this option. 
-j, --jump target
    This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below). If this option is omitted in a rule (and -g is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented. 
-g, --goto chain
    This specifies that the processing should continue in a user specified chain. Unlike the --jump option return will not continue processing in this chain but instead in the chain that called us via --jump. 
-i, --in-interface [!] name
    Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match. 
-o, --out-interface [!] name
    Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match. 
[!] -f, --fragment
    This means that the rule only refers to second and further fragments of fragmented packets. Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them. When the "!" argument precedes the "-f" flag, the rule will only match head fragments, or unfragmented packets. 
-c, --set-counters PKTS BYTES
    This enables the administrator to initialize the packet and byte counters of a rule (during INSERT, APPEND, REPLACE operations). 
-v, --verbose
    Verbose output. This option makes the list command show the interface name, the rule options (if any), and the TOS masks. The packet and byte counters are also listed, with the suffix 'K', 'M' or 'G' for 1000, 1,000,000 and 1,000,000,000 multipliers respectively (but see the -x flag to change this). For appending, insertion, deletion and replacement, this causes detailed information on the rule or rules to be printed. 
-n, --numeric
    Numeric output. IP addresses and port numbers will be printed in numeric format. By default, the program will try to display them as host names, network names, or services (whenever applicable). 
-x, --exact
    Expand numbers. Display the exact value of the packet and byte counters, instead of only the rounded number in K's (multiples of 1000) M's (multiples of 1000K) or G's (multiples of 1000M). This option is only relevant for the -L command. 
--line-numbers
    When listing rules, add line numbers to the beginning of each rule, corresponding to that rule's position in the chain. 
--modprobe=command
    When adding or inserting rules into a chain, use command to load any necessary modules (targets, match extensions, etc).
-m, --match <module_name>
```

## Quick examples

- Change the default policy for a chain

  To change the default policy of a chain, run:
  
  `iptables --policy chain_name <ACCEPT/DROP/REJECT>`

- List Entries in iptables

  `iptables -L`

- ACCEPT Connections From a Single IP Address

  `iptables -A INPUT -s 10.10.10.10 -j ACCEPT`

- REJECT INBOUND Connections for an IP on a Specific Port (SSH)

  `iptables -A INPUT -p tcp --dport ssh -s 10.10.10.10 -j REJECT`

- Saving Changes Made to iptables

  The changes you made to your iptables rules will not be saved unless it is called explicitly to be saved. The next time the service starts, any unsaved changes will be wiped away. The following are examples on how to save on different platforms

  Ubuntu: `sudo /sbin/iptables-save`

  RedHat / Centos: `/sbin/service iptables save`

  Others: `/etc/init.d/iptables save`

- Deleting Individual Rules

  You can delete rules based on what they're doing:

  `iptables -D INPUT -s 127.0.0.1 -p tcp -dport 111 -j ACCEPT `

  You can also delete based on the rule number (use `iptables -L -t table_name chain_name --line-numbers` to get the number on list):

  `iptables -D INPUT 4`

- Allow Established and Related Incoming Connections

  `iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT`

- Allow Incoming HTTPS

  `iptables -A INPUT -p tcp --dport 443 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT`

  `iptables -A OUTPUT -p tcp --sport 443 -m conntrack --ctstate ESTABLISHED -j ACCEPT`

